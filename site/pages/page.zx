
pub fn Page(ctx: zx.PageContext) zx.Component {
    return (
        <main @allocator={ctx.arena}>
            <SimpleApp @rendering={.client} @allocator={ctx.arena} />
        </main>
    );
}

const Item = struct { id: u32, text: []const u8 };

pub fn SimpleApp(allocator: zx.Allocator) zx.Component {
    if (builtin.cpu.arch == .wasm32) {
        initItems(zx.client_allocator);
    }


    return (
        <div @{allocator} class="simple-app">
            <div class="controls">
                <div class="jumbotron">
                    <h3>ZX Client-Side keyed</h3>
                </div>
                <div class="button-grid">
                    <Button onclick={create_rows} id="run" title="Create 1,000 rows" />
                    <Button onclick={create_large_rows} id="runlots" title="Create 10,000 rows" />
                    <Button onclick={append_rows} id="add" title="Append 1,000 rows" />
                    <Button onclick={updateRows} id="update" title="Update every 10th row" />
                    <Button onclick={clearRows} id="clear" title="Clear" />
                    <Button onclick={swapRows} id="swaprows" title="Swap Rows" />
                </div>
            </div>
            <ul class="item-list">
                {for (items.items) |item| (
                    <Row @allocator={allocator} item={item} selected={item.id == selected_id} />
                )}
            </ul>
        </div>
    );
}







const ButtonProps = struct { onclick: *const fn (zx.EventContext) void, title: []const u8, id: []const u8 };

fn Button(ctx: *zx.ComponentCtx(ButtonProps)) zx.Component {
    return (
        <button @allocator={ctx.allocator} type="button" onclick={ctx.props.onclick} id={ctx.props.id}>
            {ctx.props.title}
        </button>
    );
}



const RowProps = struct { item: Item, selected: bool };

fn Row(ctx: *zx.ComponentCtx(RowProps)) zx.Component {
    const item = ctx.props.item;
    const selected = ctx.props.selected;
    
    return (
        <li @allocator={ctx.allocator} class={if (selected) "list-item selected" else "list-item"}>
            {item.text}
        </li>
    );
}



var next_id: u32 = 1;
var initialized: bool = false;
var items = std.ArrayList(Item).empty;
var items_allocator: std.mem.Allocator = undefined;
var selected_id: u32 = 0;

fn initItems(allocator: zx.Allocator) void {
    if (initialized) return;
    initialized = true;
    items_allocator = allocator;
    items = std.ArrayList(Item).empty;
}



fn clearRows(_: zx.EventContext) void {
    items.clearRetainingCapacity();
    next_id = 1;
    selected_id = 0;
    zx.requestRender();
}

fn swapRows(_: zx.EventContext) void {
    if (items.items.len > 998) {
        const tmp = items.items[1];
        items.items[1] = items.items[998];
        items.items[998] = tmp;
        zx.requestRender();
    }
}

fn updateRows(_: zx.EventContext) void {
    var i: usize = 0;
    while (i < items.items.len) : (i += 10) {
        const item = &items.items[i];
        const new_text = std.fmt.allocPrint(items_allocator, "{s} !!!", .{item.text}) catch @panic("OOM");
        item.text = new_text;
    }
    zx.requestRender();
}

var seed: u32 = 12345;
fn RandomNumber(max: u32) u32 {
    seed = seed *% 1103515245 +% 12345;
    return seed % max;
}


const adjectives = [_][]const u8{
        "pretty",
        "large",
        "big",
        "small",
        "tall",
        "short",
        "long",
        "handsome",
        "plain",
        "quaint",
        "clean",
        "elegant",
        "easy",
        "angry",
        "crazy",
        "helpful",
        "mushy",
        "odd",
        "unsightly",
        "adorable",
        "important",
        "inexpensive",
        "cheap",
        "expensive",
        "fancy",
    };
const colours = [_][]const u8{ "red", "yellow", "blue", "green", "pink", "brown", "purple", "brown", "white", "black", "orange" };
const nouns = [_][]const u8{ "table", "chair", "house", "bbq", "desk", "car", "pony", "cookie", "sandwich", "burger", "pizza", "mouse", "keyboard" };

fn BuildRows(count_to_add: u32, clear_first: bool) void {
    if (clear_first) {
        items.clearRetainingCapacity();
        next_id = 1;
    }
    
    items.ensureTotalCapacity(items_allocator, items.items.len + count_to_add) catch @panic("OOM");
    
    for (0..count_to_add) |_| {
        const text = std.fmt.allocPrint(items_allocator, "{} {s} {s} {s}", .{next_id, adjectives[RandomNumber(adjectives.len)], colours[RandomNumber(colours.len)], nouns[RandomNumber(nouns.len)] }) catch @panic("OOM");
        const item = Item{
            .id = next_id,
            .text = text,
        };

        items.append(items_allocator, item) catch @panic("OOM");
        next_id += 1;
    }

    zx.requestRender();
    // count.set(@intCast(items.items.len));
}

fn create_rows(_: zx.EventContext) void {
    BuildRows(1000, true);
}
fn create_large_rows(_: zx.EventContext) void {
    BuildRows(10000, true);
}

fn append_rows(_: zx.EventContext) void {
    BuildRows(1000, false);
}

const zx = @import("zx");
const std = @import("std");
const builtin = @import("builtin");
