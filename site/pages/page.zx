pub const CounterComponent = @import("./client.zig").CounterComponent;


pub fn Page(ctx: zx.PageContext) zx.Component {
    return (
        <main @allocator={ctx.arena}>
            <SimpleApp @rendering={.client} @allocator={ctx.arena} />
            // <CounterComponent @rendering={.client} @allocator={ctx.arena} />
        </main>
    );
}
// var count: zx.Signal(i32) = .init(0);


const Item = struct { id: u32, text: []const u8 };

pub fn SimpleApp(allocator: zx.Allocator) zx.Component {
    if (builtin.cpu.arch == .wasm32) {
        initItems(zx.client_allocator);
    } else {
        resetItemsForSSR();
    }

    return (
        <div @{allocator} class="simple-app">

            
            <div class="controls">
                <div class="jumbotron">
                    <h3>{"ZX Client-Side keyed"}</h3>
                    // <h2>Row Count: {&count}</h2>
                    <div class="button-grid">
                        <form method="create_row" onsubmit={create_rows}>
                            <button type="submit" class="add-btn">Create 1,000 rows</button>
                        </form>
                        <form method="create_large_row" onsubmit={create_large_rows}>
                            <button type="submit" class="add-btn">Create 10,000 rows</button>
                        </form>
                        <form method="append_rows" onsubmit={append_rows}>
                            <button type="submit" class="add-btn">Append 1,000 rows</button>
                        </form>
                        <form method="update_rows" onsubmit={updateRows}>
                            <button type="submit" class="add-btn" name="action" value="update">Update every 10th row</button>
                        </form>
                        <form method="clear_rows" onsubmit={clearRows}>
                            <button type="submit" class="add-btn">Clear</button>
                        </form>
                        <form method="swap_rows" onsubmit={swapRows}>
                            <button type="submit" class="btn" name="action" value="swaprows">Swap Rows</button>
                        </form>
                    </div>
                </div>

            </div>


            <ul class="item-list">
                {for (items.items) |item| (
                    <li class="list-item">
                        <span>{item.text}</span>
                    </li>
                )}
            </ul>
        </div>
    );
}

var next_id: u32 = 1;
var initialized: bool = false;
var items = std.ArrayList(Item).empty;
var items_allocator: std.mem.Allocator = undefined;

fn initItems(allocator: zx.Allocator) void {
    if (initialized) return;
    initialized = true;
    items_allocator = allocator;
    items = std.ArrayList(Item).empty;
}

fn resetItemsForSSR() void {
    items = std.ArrayList(Item).empty;
    next_id = 1;
}

fn clearRows(ctx: zx.EventContext) void {
    ctx.preventDefault();
    if (comptime builtin.cpu.arch != .wasm32) return;
    items.clearRetainingCapacity();
    next_id = 1;
    zx.requestRender();
}

fn swapRows(ctx: zx.EventContext) void {
    ctx.preventDefault();
    if (comptime builtin.cpu.arch != .wasm32) return;
    if (items.items.len > 998) {
        const tmp = items.items[1];
        items.items[1] = items.items[998];
        items.items[998] = tmp;
        zx.requestRender();
    }
}

fn updateRows(ctx: zx.EventContext) void {
    ctx.preventDefault();
    if (comptime builtin.cpu.arch != .wasm32) return;
    var i: usize = 0;
    while (i < items.items.len) : (i += 10) {
        const item = &items.items[i];
        const new_text = std.fmt.allocPrint(items_allocator, "{s} !!!", .{item.text}) catch @panic("OOM");
        item.text = new_text;
    }
    zx.requestRender();
}

var prng = std.Random.DefaultPrng.init(123456789);
fn RandomNumber(max: u32) u32 {
    return @intCast(prng.random().uintLessThan(u64, max));
}

fn BuildRows(count_to_add: u32, clear_first: bool) void {
    if (clear_first) {
        items.clearRetainingCapacity();
        next_id = 1;
    }
    const adjectives = [_][]const u8{
        "pretty",
        "large",
        "big",
        "small",
        "tall",
        "short",
        "long",
        "handsome",
        "plain",
        "quaint",
        "clean",
        "elegant",
        "easy",
        "angry",
        "crazy",
        "helpful",
        "mushy",
        "odd",
        "unsightly",
        "adorable",
        "important",
        "inexpensive",
        "cheap",
        "expensive",
        "fancy",
    };
    const colours = [_][]const u8{
        "red",
        "yellow",
        "blue",
        "green",
        "pink",
        "brown",
        "purple",
        "brown",
        "white",
        "black",
        "orange"
    };
    const nouns = [_][]const u8{
        "table",
        "chair",
        "house",
        "bbq",
        "desk",
        "car",
        "pony",
        "cookie",
        "sandwich",
        "burger",
        "pizza",
        "mouse",
        "keyboard"
    };
    
    for (0..count_to_add) |_| {
        const text = std.fmt.allocPrint(items_allocator,  "{}. {s} {s} {s}", .{next_id, adjectives[RandomNumber(adjectives.len)], colours[RandomNumber(colours.len)], nouns[RandomNumber(nouns.len)]}) catch @panic("OOM");
        const item = Item{
            .id = next_id,
            .text = text,
        };
        
        items.append(items_allocator, item) catch @panic("OOM");
        next_id += 1;
    }
    
    zx.requestRender();
    // count.set(@intCast(items.items.len));
}

fn create_rows(ctx: zx.EventContext) void {
    ctx.preventDefault();
    if (comptime builtin.cpu.arch != .wasm32) return;
    BuildRows(1000, true);
}
fn create_large_rows(ctx: zx.EventContext) void {
    ctx.preventDefault();
    if (comptime builtin.cpu.arch != .wasm32) return;
    BuildRows(10000, true);
}

fn append_rows(ctx: zx.EventContext) void {
    ctx.preventDefault();
    if (comptime builtin.cpu.arch != .wasm32) return;
    BuildRows(1000, false);
}

const zx = @import("zx");
const std = @import("std");
const builtin = @import("builtin");
const client = zx.client;
const js = zx.Client.js;
